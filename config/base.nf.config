import groovy.time.TimeDuration

// Dynamic queue allocation functions
def timedur(x){
    return new TimeDuration(*x.split(':').collect{it.toInteger()}, 0)
}

def get_queue(w, mapping){
    // [String : String] --> [TimeDuration : String]
    td_mapping = mapping.collectEntries{k,v -> [timedur(k), v]}
    td_w = timedur(w)
    ps = td_mapping.grep{it.key >= td_w}.sort{it.key}
    return ps.first().value
}

if (!(cluster_time instanceof Closure)){
    params.cluster_time = { s -> cluster_time }
}else{
    params.cluster_time = cluster_time
}

singularity {

    autoMounts=true
    enabled=true

}

retry_val=3
license="/freesurfer/6.0.0/build/"

profiles {

    //DEFAULT
    standard {
        params.cluster_queue = {s->"high-moby"}
        process.executor = "SLURM"
        process.queue = "high-moby"
        params.license = "/opt/quarantine/$license"
        params.scratchDir = "/tmp/"
    }

    kimel {
        params.cluster_queue = {s->"high-moby"}
        process.executor = "SLURM"
        params.license = "/opt/quarantine/$license"
        params.scratchDir = "/tmp/"
    }

    scc {
        partition_map = ["2:00:00": "short",
                        "12:00:00": "medium",
                        "1:00:00:00": "long",
                        "166:16:00:00": "verylong"]

        params.cluster_queue = { s -> get_queue(params.cluster_time(s),
                                                partition_map)
                               }

        process.executor = "SLURM"
        params.license = "/KIMEL/quarantine/$license"
        params.scratchDir = "/export/ramdisk/"
    }

    local {
        params.cluster_queue = {s->""}
        process.executor = "local"
        process.maxForks = 4
        params.license = "/opt/quarantine/$license"
        params.scratchDir = "/tmp/"
    }
}


// Caching mechanism
Closure cacheDir;
if (params.cache_dir){
    cacheDir = { f ->
                    def d = new File("$params.cache_dir/$f")
                    d.mkdirs()
                    "$params.cache_dir/$f"
               }
}else{
    cacheDir = { f -> "" }
}

process {

    errorStrategy = {task.attempt == 3 ? "finish" : "retry"}

    // Common labels
    withLabel: ants{
        container = params.ants_img
    }

    withLabel: connectome{
        container = params.connectome_img
        containerOptions = "-B ${params.atlas}:/atlas"
    }

    withLabel: freesurfer{
        container = params.freesurfer_img
        containerOptions = "-B ${params.license}:/license"
        beforeScript = "export SINGULARITYENV_FS_LICENSE=/license/license.txt"
    }

    withLabel: simnibs{
        container = params.simibs_img
    }

    withName: antsRegistration{
        queue = {get_partition(task.time)}
        storeDir = cacheDir("antsRegistration")
        cpus = 8
        clusterOptions = "--mem-per-cpu=2G"
        time = "00:10:00"
        executor="${engine}"
    }
}
